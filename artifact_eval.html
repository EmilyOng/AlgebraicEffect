
<h1 id="artifact-56-for-evaluation-for-popl22">Artifact #27 for TACAS'22 Tool Paper Submission 26</h1>

<p>There are two artifacts for this work, the Coq formalization and the tool PwTer. Each is described in turn.</p>

<h4 id="quick-links">Quick links</h4>
<ul>
  <li>Browse the development at GitHub: <a href="https://github.com/weakmemory/pwt">online</a></li>
  <li>Browse the PwTer source code at GitHub: <a href="https://github.com/graymalkin/pomsets-with-predicate-transformers">online</a></li>
  <li>VirtualBox image: <a href="https://podkopaev.net/popl22-pwt-artifact.html">online</a></li>
</ul>

<h2 id="pomsets-w-transformers-a-coq-formalization">Pomsets w/ Transformers (a Coq formalization)</h2>

<p>This artifact contains Coq code supplementing the paper <em>Leaky Semicolon: Compositional Semantic Dependencies for Relaxed-Memory Concurrency</em> by 
Alan Jeffrey, James Riely, Mark Batty, Simon Cooksey, Ilya Kaysin, and Anton Podkopaev.</p>

<h3 id="getting-started">Getting started</h3>
<p>The artifact consists of Coq formalization and proofs about <em>Pomsets w/ Transformers</em>.
There are two ways to evaluate the artifact:</p>
<ul>
  <li>by using a virtual machine (VM) prepared by us;</li>
  <li>by using your own Coq setup via <code class="language-plaintext highlighter-rouge">opam</code>.
Below, we provide guidance for both approaches.
<em>We propose to start with building the project by following our instructions and then take a look at the main definitions and lemmas.</em></li>
</ul>

<h3 id="using-the-virtual-machine">Using the Virtual Machine</h3>
<p>You need to get a <a href="https://www.virtualbox.org/">VirtualBox</a> (tested w/ version 6.1.26) on your system and import the VM
<code class="language-plaintext highlighter-rouge">pwt.ova</code>. Please, note the following:</p>
<ul>
  <li>The VM should be provided with at least 8GB of RAM.</li>
  <li>The VM is better to be provided with 4 CPUs (but 2 CPUs should be enough).</li>
  <li>The VM is a Ubuntu 18.04 with <code class="language-plaintext highlighter-rouge">coq</code>, <code class="language-plaintext highlighter-rouge">coqide</code>, <code class="language-plaintext highlighter-rouge">vim</code> and <code class="language-plaintext highlighter-rouge">emacs</code> being set-up.</li>
  <li>Username and password are both <code class="language-plaintext highlighter-rouge">vagrant</code>.</li>
</ul>

<p>The Coq code can be found in the folder <code class="language-plaintext highlighter-rouge">/home/vagrant/artifact</code>. To compile it,
you need to run <code class="language-plaintext highlighter-rouge">cd /home/vagrant/artifact &amp;&amp; make -j4</code> in a terminal.
The same but pre-compiled code is located in the folder <code class="language-plaintext highlighter-rouge">/home/vagrant/artifact_compiled</code>.</p>

<p>There is a CoqIDE shortcut on the desktop, which could be used to explore the development.</p>

<h3 id="using-your-own-coq-setup-with-opam">Using your own Coq setup with opam</h3>
<p>All required dependencies can be installed via package manager <a href="https://opam.ocaml.org/"><code class="language-plaintext highlighter-rouge">opam</code> (version &gt;= 2.0)</a>
by running <code class="language-plaintext highlighter-rouge">./configure</code> from the project’s root folder.
It installs:</p>
<ul>
  <li><a href="https://coq.inria.fr">Coq 8.13</a></li>
  <li><a href="https://github.com/vafeiadis/hahn">Hahn library</a> (<code class="language-plaintext highlighter-rouge">coq-hahn</code>)</li>
  <li><a href="https://github.com/weakmemory/imm">Intermediate Memory Model</a> (<code class="language-plaintext highlighter-rouge">coq-imm.1.4</code>)</li>
</ul>

<p>The compilation and installation of <code class="language-plaintext highlighter-rouge">coq-imm.1.4</code> may take a lot of time (&gt; 40 min).</p>

<p>After that, you may build the project by running <code class="language-plaintext highlighter-rouge">make -j4</code> from the project’s root folder.</p>

<h2 id="checking-the-artifacts-code">Checking the artifact’s code</h2>
<p>After the project is compiled, you may want to check how the main definitions and results in Coq are related to the ones in the paper.</p>

<table>
  <thead>
    <tr>
      <th>Paper</th>
      <th>Description</th>
      <th>Coq file</th>
      <th>Coq statements</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>§4.1</td>
      <td>definitions of statements <em>S</em> and expressions <em>M</em></td>
      <td><code class="language-plaintext highlighter-rouge">Language.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Expr.t</code> and <code class="language-plaintext highlighter-rouge">Stmt.t</code></td>
    </tr>
    <tr>
      <td>§4.3, Def. 4.2</td>
      <td>a definition of predicate transformers</td>
      <td><code class="language-plaintext highlighter-rouge">PredTransformer.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Record predTransformer</code></td>
    </tr>
    <tr>
      <td>§4.3, Def. 4.4; §A.3, Def. A.2</td>
      <td>a definition of pomsets with predicate transformers; a definition of complete pomsets</td>
      <td><code class="language-plaintext highlighter-rouge">Pomset.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Record pomset</code>, <code class="language-plaintext highlighter-rouge">Record wf</code> <br /> (well-formedness predicate), and <code class="language-plaintext highlighter-rouge">Record complete</code></td>
    </tr>
    <tr>
      <td>§4.3, Fig. 1 and <br /> §9.4, Def. 9.6</td>
      <td>the PwT semantics extended to allow if-closure</td>
      <td><code class="language-plaintext highlighter-rouge">Semantics.v</code></td>
      <td><code class="language-plaintext highlighter-rouge">Inductive Semantics</code></td>
    </tr>
  </tbody>
  <tbody>
    <tr>
      <td>§4.3, Lemma 4.5a</td>
      <td><code class="language-plaintext highlighter-rouge">skip</code> as an identity element for the semicolon operator</td>
      <td><code class="language-plaintext highlighter-rouge">SeqSkipId.v</code></td>
      <td>lemmas  <code class="language-plaintext highlighter-rouge">skip_seq_id_left</code> <br /> and <code class="language-plaintext highlighter-rouge">skip_seq_id_right</code></td>
    </tr>
    <tr>
      <td>§4.3, Lemma 4.5b</td>
      <td>associativity of the semicolon operator</td>
      <td><code class="language-plaintext highlighter-rouge">SeqAssoc.v</code></td>
      <td>lemma <code class="language-plaintext highlighter-rouge">seq_assoc</code></td>
    </tr>
    <tr>
      <td>§4.3, Lemma 4.6e</td>
      <td>distribution of the if operator over semicolon</td>
      <td><code class="language-plaintext highlighter-rouge">IfClosure.v</code></td>
      <td>lemma <code class="language-plaintext highlighter-rouge">if_closure</code></td>
    </tr>
  </tbody>
</table>

<p>Our proofs of the main lemmas use the following axioms (and no other assumptions):</p>
<ul>
  <li>Excluded middle, XM (<code class="language-plaintext highlighter-rouge">classic</code> from <code class="language-plaintext highlighter-rouge">Coq.Logic.Classical_Prop</code>);</li>
  <li>(Dependent) Functional Extensionality, (D)FE (<code class="language-plaintext highlighter-rouge">functional_extensionality_dep</code> from <code class="language-plaintext highlighter-rouge">Coq.Logic.FunctionalExtensionality</code>);</li>
  <li>Constructive Definite Description, CDD (<code class="language-plaintext highlighter-rouge">constructive_definite_description</code> from <code class="language-plaintext highlighter-rouge">Coq.Logic.Description</code>).</li>
</ul>

<p>You may check that by taking a look at files</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">skip_seq_id_left.axioms.out</code>, <code class="language-plaintext highlighter-rouge">skip_seq_id_right.axioms.out</code>, <code class="language-plaintext highlighter-rouge">seq_assoc.axioms.out</code>, and <code class="language-plaintext highlighter-rouge">if_closure.axioms.out</code>.</li>
</ul>

<p>They are generated during the project compilation by <code class="language-plaintext highlighter-rouge">Print Assumptions</code> instructions at the end of <code class="language-plaintext highlighter-rouge">SeqSkipId.v</code>, <code class="language-plaintext highlighter-rouge">SeqAssoc.v</code>, and <code class="language-plaintext highlighter-rouge">IfClosure.v</code> files.</p>

<p>To check that the project does not contain admitted facts, you may want to run the following script from the project’s root folder:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep </span>dmit src/<span class="k">*</span>.v

</code></pre></div></div>

<h3 id="description-of-the-projects-files">Description of the project’s files</h3>

<h4 id="basic-definitions-of-the-semantics">Basic definitions of the semantics</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Events.v</code> – a definition of events (§4.1)</li>
  <li><code class="language-plaintext highlighter-rouge">Language.v</code> – definitions of statements <em>S</em> and expressions <em>M</em> (§4.1)</li>
  <li><code class="language-plaintext highlighter-rouge">Formula.v</code> – a language of formulas Φ (§4.1)</li>
  <li><code class="language-plaintext highlighter-rouge">Action.v</code> — a definition of actions and related notions (§4.2)</li>
  <li><code class="language-plaintext highlighter-rouge">PredTransformer.v</code> — a definition of predicate transformers (§4.3, Def. 4.2)</li>
  <li><code class="language-plaintext highlighter-rouge">Pomset.v</code> — a definition of pomsets with predicate transformers (§4.3, Def. 4.4)</li>
  <li><code class="language-plaintext highlighter-rouge">Semantics.v</code> — the PwT semantics extended to allow if-closure (§4.3, Fig. 1 and §9.4, Def. 9.6)</li>
</ul>

<h4 id="properties-of-the-semantics">Properties of the semantics</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SeqSkipId.v</code> — <code class="language-plaintext highlighter-rouge">skip</code> as an identity element for the semicolon operator (§4.3, Lemma 4.5a)</li>
  <li><code class="language-plaintext highlighter-rouge">SeqAssoc.v</code> — associativity of the semicolon operator (§4.3, Lemma 4.5b)</li>
  <li><code class="language-plaintext highlighter-rouge">IfClosure.v</code> — distribution of the if operator over semicolon (§4.3, Lemma 4.6e)</li>
</ul>

<h4 id="auxiliary-definitions-and-lemmas">Auxiliary definitions and lemmas</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AuxDef.v</code>, <code class="language-plaintext highlighter-rouge">AuxRel.v</code>, <code class="language-plaintext highlighter-rouge">SeqBuilder.v</code></li>
</ul>

<h2 id="pwter">PwTer</h2>

<p>PwTer can be found on the desktop of the virtual machine described above, by following the <code class="language-plaintext highlighter-rouge">PwTer</code> shortcut on the
desktop.</p>

<p>Alternatively, it can be built on your own machine by following the instructions in <a href="https://github.com/graymalkin/pomsets-with-predicate-transformers">the
project</a>’s README.</p>

<p>Once the tool is built, to replicate the results presented in the paper, navigate to the <code class="language-plaintext highlighter-rouge">data</code> directory of the PwTer
sources and run <code class="language-plaintext highlighter-rouge">make check</code>. This will evaluate the Java Causality Test Cases.</p>

<h3 id="tool-structure">Tool structure</h3>

<p>Most of the source is boiler plate to tie together parsers, the two interesting files are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">src/Preliminaries.ml</code> contains the interface to Z3</li>
  <li><code class="language-plaintext highlighter-rouge">src/PomsetPTSeq.ml</code> implements the semantics as presented in Figure 1, with register recycling. The paper’s rules are referenced in comments like <code class="language-plaintext highlighter-rouge">(* M6 *)</code> and <code class="language-plaintext highlighter-rouge">(* R4a *)</code>.</li>
</ul>

<p>The tool has been written to be faithful to the mathematics without too much deviation for efficiency’s sake. The
majority of the complexity is in the implementation of <code class="language-plaintext highlighter-rouge">seq_rule</code> and <code class="language-plaintext highlighter-rouge">if_rule</code>, as these have to implement merging. In
PwTer, all events have globally unique identifiers, so possible valid merges have to be calculated at these compositions
and new labellings must be produced. This yields quite a lot of fiddly maps which have to be applied carefully to
preserve the semantics.</p>
